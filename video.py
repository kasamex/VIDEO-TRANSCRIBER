#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VIDEO TRANSCRIBER - VERS√ÉO AVAN√áADA
Sistema plug-and-play com detec√ß√£o de speakers, m√∫ltiplos formatos e grava√ß√£o ao vivo
Instala automaticamente todas as depend√™ncias necess√°rias
"""
import os
import subprocess
import sys
import tempfile
import json
import urllib.request
import zipfile
import shutil
import re
import platform
import time
import threading
from pathlib import Path
from datetime import datetime, timedelta

class EnhancedVideoTranscriber:
    def __init__(self):
        print("üéôÔ∏è Iniciando Video Transcriber Avan√ßado...")
        self.system = platform.system().lower()
        self.setup_folders()
        # Idiomas mantidos para exibi√ß√£o e detec√ß√£o, mas sem funcionalidade de tradu√ß√£o
        self.languages = {
            'pt': 'Portugu√™s',
            'en': 'English',
            'es': 'Espa√±ol',
            'fr': 'Fran√ßais',
            'de': 'Deutsch',
            'it': 'Italiano',
            'ja': 'Êó•Êú¨Ë™û',
            'ko': 'ÌïúÍµ≠Ïñ¥',
            'zh': '‰∏≠Êñá',
            'ru': '–†—É—Å—Å–∫–∏–π'
        }

    def setup_folders(self):
        """Criar estrutura de pastas"""
        base_dir = Path(__file__).parent
        self.folders = {
            'downloads': base_dir / 'video_downloads',
            'audio': base_dir / 'extracted_audio',
            'transcripts': base_dir / 'transcriptions',
            'tools': base_dir / 'video_tools',
            'models': base_dir / 'translation_models', # Pasta mantida por compatibilidade
            'recordings': base_dir / 'live_recordings'
        }
        for folder_path in self.folders.values():
            folder_path.mkdir(exist_ok=True)
            print(f"‚úÖ {folder_path.name}: {folder_path}")

    def install_package(self, package_name, import_name=None):
        """Instalar pacote Python"""
        if import_name is None:
            import_name = package_name
        try:
            __import__(import_name)
            print(f"‚úÖ {package_name} j√° instalado")
            return True
        except ImportError:
            print(f"üì¶ Instalando {package_name}...")
            try:
                subprocess.check_call([
                    sys.executable, '-m', 'pip', 'install', package_name,
                    '--quiet', '--disable-pip-version-check'
                ])
                print(f"‚úÖ {package_name} instalado com sucesso!")
                return True
            except Exception as e:
                print(f"‚ùå Erro instalando {package_name}: {e}")
                return False

    def setup_dependencies(self):
        """Instalar todas as depend√™ncias automaticamente"""
        print("\nüîß Configurando depend√™ncias...")
        # Lista de depend√™ncias essenciais (argostranslate removido)
        dependencies = [
            ('yt-dlp', 'yt_dlp'),
            ('openai-whisper', 'whisper'),
            ('torch', 'torch'),
            ('torchaudio', 'torchaudio'),
            ('pyaudio', 'pyaudio'),
            ('librosa', 'librosa'),
            ('pyannote.audio', 'pyannote'),
            ('reportlab', 'reportlab'),
            ('sounddevice', 'sounddevice'),
            ('scipy', 'scipy'),
            ('numpy', 'numpy'),
        ]
        failed_deps = []
        for package, import_name in dependencies:
            if not self.install_package(package, import_name):
                failed_deps.append(package)
        if failed_deps:
            print(f"‚ö†Ô∏è Falha ao instalar: {', '.join(failed_deps)}")
            print("‚ö†Ô∏è Algumas funcionalidades podem n√£o funcionar")
        print("‚úÖ Setup de depend√™ncias conclu√≠do!")
        return True

    def setup_ffmpeg(self):
        """Configurar FFmpeg automaticamente - Prioriza o local da pasta tools"""
        # 1. Verificar se j√° existe na pasta tools PRIMEIRO
        ffmpeg_path = self.folders['tools'] / ('ffmpeg.exe' if self.system == 'windows' else 'ffmpeg')
        if ffmpeg_path.exists():
            print("‚úÖ FFmpeg encontrado na pasta tools")
            # Adicionar ao PATH para que o Whisper encontre
            os.environ['PATH'] = str(self.folders['tools']) + os.pathsep + os.environ.get('PATH', '')
            return str(ffmpeg_path)
        
        # 2. TENTAR FFmpeg do sistema
        try:
            print("üîç Verificando FFmpeg do sistema...")
            result = subprocess.run(
                ['ffmpeg', '-version'],
                capture_output=True,
                text=True,
                check=True,
                shell=(self.system == 'windows')
            )
            if result.returncode == 0:
                print("‚úÖ FFmpeg do sistema dispon√≠vel")
                return 'ffmpeg'
        except (FileNotFoundError, subprocess.CalledProcessError) as e:
            print(f"‚ö†Ô∏è FFmpeg do sistema n√£o encontrado ou n√£o funcionando: {e}")
        except Exception as e:
             print(f"‚ö†Ô∏è Erro inesperado ao verificar FFmpeg do sistema: {e}")

        # 3. Download autom√°tico para Windows
        if self.system == 'windows':
            downloaded_path = self.download_ffmpeg_windows()
            if downloaded_path:
                # Adicionar ao PATH ap√≥s download
                os.environ['PATH'] = str(self.folders['tools']) + os.pathsep + os.environ.get('PATH', '')
                return downloaded_path
            else:
                print("‚ùå Falha ao baixar FFmpeg.")

        # 4. √öltimo recurso: Avisar para instalar manualmente
        print("‚ö†Ô∏è FFmpeg n√£o encontrado. √â essencial para o funcionamento.")
        print("üí° Tente instalar manualmente:")
        if self.system == 'windows':
            print("   - winget install FFmpeg")
            print("   - Ou baixe de https://www.gyan.dev/ffmpeg/builds/ e adicione ao PATH")
        else:
            print("   - Ubuntu/Debian: sudo apt install ffmpeg")
            print("   - macOS: brew install ffmpeg")
        return None

    def download_ffmpeg_windows(self):
        """Download autom√°tico do FFmpeg para Windows"""
        print("üì• Baixando FFmpeg para Windows...")
        try:
            url = "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip"
            temp_zip = tempfile.gettempdir() + "/ffmpeg.zip"
            # Download
            urllib.request.urlretrieve(url, temp_zip)
            # Extrair
            temp_dir = tempfile.gettempdir() + "/ffmpeg_temp"
            with zipfile.ZipFile(temp_zip, 'r') as zip_ref:
                zip_ref.extractall(temp_dir)
            # Encontrar e mover execut√°veis
            for root, dirs, files in os.walk(temp_dir):
                for file in files:
                    if file in ['ffmpeg.exe', 'ffprobe.exe']:
                        src = os.path.join(root, file)
                        dst = self.folders['tools'] / file
                        shutil.move(src, dst)
            # Limpeza
            shutil.rmtree(temp_dir, ignore_errors=True)
            os.remove(temp_zip)
            ffmpeg_path = self.folders['tools'] / 'ffmpeg.exe'
            if ffmpeg_path.exists():
                print("‚úÖ FFmpeg baixado e configurado!")
                return str(ffmpeg_path)
        except Exception as e:
            print(f"‚ùå Erro baixando FFmpeg: {e}")
        return None

    def record_audio_live(self, duration_seconds=None):
        """Gravar √°udio ao vivo do microfone"""
        print("üé§ Iniciando grava√ß√£o ao vivo...")
        try:
            import sounddevice as sd
            import numpy as np
            from scipy.io.wavfile import write
            # Configura√ß√µes de grava√ß√£o
            sample_rate = 16000  # Hz
            channels = 1  # Mono
            if duration_seconds:
                print(f"‚è±Ô∏è Gravando por {duration_seconds} segundos...")
                print("üî¥ Gravando... Fale agora!")
                # Gravar por tempo determinado
                audio_data = sd.rec(
                    int(duration_seconds * sample_rate),
                    samplerate=sample_rate,
                    channels=channels,
                    dtype=np.int16
                )
                sd.wait()  # Aguardar conclus√£o
            else:
                print("üî¥ Gravando... Pressione Enter para parar!")
                # Gravar at√© o usu√°rio pressionar Enter
                audio_chunks = []

                def callback(indata, frames, time, status):
                    audio_chunks.append(indata.copy())

                # Iniciar stream
                stream = sd.InputStream(
                    callback=callback,
                    samplerate=sample_rate,
                    channels=channels,
                    dtype=np.int16
                )
                with stream:
                    input()  # Aguardar Enter
                # Concatenar chunks
                if audio_chunks:
                    audio_data = np.concatenate(audio_chunks, axis=0)
                else:
                    print("‚ùå Nenhum √°udio gravado")
                    return None
            # Salvar arquivo
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"recording_{timestamp}.wav"
            filepath = self.folders['recordings'] / filename
            write(str(filepath), sample_rate, audio_data)
            file_size = filepath.stat().st_size / (1024 * 1024)
            duration = len(audio_data) / sample_rate
            print(f"‚úÖ Grava√ß√£o salva: {filename}")
            print(f"üìä Dura√ß√£o: {duration:.1f}s, Tamanho: {file_size:.1f}MB")
            return str(filepath)
        except ImportError:
            print("‚ùå Biblioteca de √°udio n√£o instalada")
            print("Instale com: pip install sounddevice scipy")
            return None
        except Exception as e:
            print(f"‚ùå Erro na grava√ß√£o: {e}")
            return None

    def detect_speakers(self, audio_path):
        """Detectar e separar speakers no √°udio"""
        print("üë• Detectando speakers...")
        try:
            from pyannote.audio import Pipeline
            # Carregar pipeline de diariza√ß√£o
            print("üì¶ Carregando modelo de detec√ß√£o de speakers...")
            print("‚è≥ Primeira vez pode demorar (download do modelo)...")
            pipeline = Pipeline.from_pretrained("pyannote/speaker-diarization-3.1")
            # Processar √°udio
            print("üîÑ Analisando speakers...")
            diarization = pipeline(audio_path)
            # Extrair informa√ß√µes dos speakers
            speakers_info = []
            for turn, _, speaker in diarization.itertracks(yield_label=True):
                speakers_info.append({
                    'speaker': speaker,
                    'start': turn.start,
                    'end': turn.end,
                    'duration': turn.end - turn.start
                })
            # Estat√≠sticas
            unique_speakers = set(info['speaker'] for info in speakers_info)
            print(f"‚úÖ Detectados {len(unique_speakers)} speakers:")
            for speaker in sorted(unique_speakers):
                speaker_time = sum(
                    info['duration'] for info in speakers_info
                    if info['speaker'] == speaker
                )
                print(f"  {speaker}: {speaker_time:.1f}s")
            return speakers_info
        except ImportError:
            print("‚ùå pyannote.audio n√£o instalado")
            print("Instale com: pip install pyannote.audio")
            return None
        except Exception as e:
            print(f"‚ùå Erro na detec√ß√£o de speakers: {e}")
            return None

    def transcribe_with_speakers(self, audio_path):
        """Transcrever √°udio com detec√ß√£o de speakers"""
        print("üéôÔ∏è Transcrevendo com detec√ß√£o de speakers...")
        # Primeira transcri√ß√£o normal
        transcription_data, language = self.transcribe_audio(audio_path)
        if not transcription_data:
            return None, None
        # Detec√ß√£o de speakers
        speakers_info = self.detect_speakers(audio_path)
        if speakers_info:
            # Combinar transcri√ß√£o com speakers
            print("üîó Combinando transcri√ß√£o com speakers...")
            # Simplificado: associar segmentos de tempo
            enhanced_transcription = {
                'language': language,
                'text': transcription_data['text'] if isinstance(transcription_data, dict) else transcription_data,
                'segments': transcription_data.get('segments', []) if isinstance(transcription_data, dict) else [],
                'speakers': speakers_info
            }
            return enhanced_transcription, language
        else:
            # Fallback para transcri√ß√£o normal
            return transcription_data, language

    def export_to_srt(self, transcription_data, output_path):
        """Exportar transcri√ß√£o para formato SRT (legendas)"""
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                if isinstance(transcription_data, dict) and 'segments' in transcription_data:
                    # Com timestamps
                    for i, segment in enumerate(transcription_data['segments'], 1):
                        start_time = self.seconds_to_srt_time(segment['start'])
                        end_time = self.seconds_to_srt_time(segment['end'])
                        text = segment['text'].strip()
                        f.write(f"{i}\n")
                        f.write(f"{start_time} --> {end_time}\n")
                        f.write(f"{text}\n\n")
                else:
                    # Sem timestamps - dividir em blocos
                    text = transcription_data['text'] if isinstance(transcription_data, dict) else transcription_data
                    words = text.split()
                    words_per_subtitle = 10
                    duration_per_subtitle = 3
                    for i in range(0, len(words), words_per_subtitle):
                        chunk = ' '.join(words[i:i+words_per_subtitle])
                        start_seconds = i // words_per_subtitle * duration_per_subtitle
                        end_seconds = start_seconds + duration_per_subtitle
                        start_time = self.seconds_to_srt_time(start_seconds)
                        end_time = self.seconds_to_srt_time(end_seconds)
                        f.write(f"{i//words_per_subtitle + 1}\n")
                        f.write(f"{start_time} --> {end_time}\n")
                        f.write(f"{chunk}\n\n")
            print(f"‚úÖ SRT salvo: {output_path}")
            return True
        except Exception as e:
            print(f"‚ùå Erro salvando SRT: {e}")
            return False

    def seconds_to_srt_time(self, seconds):
        """Converter segundos para formato SRT (HH:MM:SS,mmm)"""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millisecs = int((seconds % 1) * 1000)
        return f"{hours:02d}:{minutes:02d}:{secs:02d},{millisecs:03d}"

    def export_to_json(self, transcription_data, output_path):
        """Exportar para JSON com metadados completos"""
        try:
            export_data = {
                'metadata': {
                    'generated_at': datetime.now().isoformat(),
                    'tool': 'Enhanced Video Transcriber',
                    'whisper_model': 'base'
                },
                'transcription': transcription_data
            }
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            print(f"‚úÖ JSON salvo: {output_path}")
            return True
        except Exception as e:
            print(f"‚ùå Erro salvando JSON: {e}")
            return False

    def export_to_pdf(self, title, original_text, translated_text, source_lang, target_lang, output_path):
        """Exportar para PDF formatado"""
        try:
            from reportlab.lib.pagesizes import A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import inch
            # Criar documento
            doc = SimpleDocTemplate(str(output_path), pagesize=A4)
            styles = getSampleStyleSheet()
            # Estilos customizados
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=16,
                spaceAfter=30,
            )
            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading2'],
                fontSize=14,
                spaceAfter=12,
            )
            # Conte√∫do
            story = []
            # T√≠tulo
            story.append(Paragraph(f"TRANSCRI√á√ÉO - {title}", title_style))
            story.append(Spacer(1, 12))
            # Metadados
            story.append(Paragraph("INFORMA√á√ïES", heading_style))
            story.append(Paragraph(f"Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}", styles['Normal']))
            story.append(Paragraph(f"Idioma original: {self.languages.get(source_lang, source_lang)}", styles['Normal']))
            story.append(Spacer(1, 20))
            # Transcri√ß√£o original
            story.append(Paragraph("TRANSCRI√á√ÉO ORIGINAL", heading_style))
            # Quebrar texto em par√°grafos
            paragraphs = original_text.split('\n')
            for para in paragraphs:
                if para.strip():
                    story.append(Paragraph(para.strip(), styles['Normal']))
                    story.append(Spacer(1, 6))
            # Gerar PDF
            doc.build(story)
            print(f"‚úÖ PDF salvo: {output_path}")
            return True
        except ImportError:
            print("‚ùå reportlab n√£o instalado")
            print("Instale com: pip install reportlab")
            return False
        except Exception as e:
            print(f"‚ùå Erro salvando PDF: {e}")
            return False

    def download_video(self, url):
        """Download de v√≠deo do YouTube"""
        try:
            import yt_dlp
            output_template = str(self.folders['downloads'] / '%(title)s.%(ext)s')
            ydl_opts = {
                'format': 'best[height<=720]/best',
                'outtmpl': output_template,
                'writesubtitles': False,
                'writeautomaticsub': False,
            }
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                print("üîç Obtendo informa√ß√µes do v√≠deo...")
                info = ydl.extract_info(url, download=False)
                title = info.get('title', 'video')
                duration = info.get('duration', 0)
                print(f"üìπ T√≠tulo: {title}")
                if duration:
                    print(f"‚è±Ô∏è Dura√ß√£o: {duration//60}:{duration%60:02d}")
                if duration > 3600:  # > 1 hora
                    response = input("\n‚ö†Ô∏è V√≠deo longo (>1h). Continuar? (s/n): ")
                    if response.lower() not in ['s', 'sim', 'y', 'yes']:
                        return None, None
                print("\nüì• Baixando v√≠deo...")
                ydl.download([url])
                # Encontrar arquivo baixado
                for file_path in self.folders['downloads'].glob('*'):
                    if file_path.suffix.lower() in ['.mp4', '.mkv', '.avi', '.mov', '.webm']:
                        print(f"‚úÖ Baixado: {file_path.name}")
                        return str(file_path), title
        except Exception as e:
            print(f"‚ùå Erro no download: {e}")
        return None, None

    def extract_audio(self, video_path, title, ffmpeg_cmd):
        """Extrair √°udio do v√≠deo"""
        print("üéµ Extraindo √°udio...")
        safe_title = re.sub(r'[<>:"/\\|?*]', '_', title)
        audio_path = self.folders['audio'] / f"{safe_title}.wav"
        cmd = [
            ffmpeg_cmd,
            '-i', video_path,
            '-vn', '-acodec', 'pcm_s16le',
            '-ar', '16000', '-ac', '1',
            '-loglevel', 'error',
            str(audio_path), '-y'
        ]
        try:
            subprocess.run(cmd, check=True, capture_output=True)
            if audio_path.exists():
                size_mb = audio_path.stat().st_size / (1024 * 1024)
                print(f"‚úÖ √Åudio extra√≠do: {audio_path.name} ({size_mb:.1f}MB)")
                return str(audio_path)
        except Exception as e:
            print(f"‚ùå Erro extraindo √°udio: {e}")
        return None

    def transcribe_audio(self, audio_path):
        """Transcrever √°udio com Whisper - VERS√ÉO CORRIGIDA"""
        print("üéôÔ∏è Transcrevendo √°udio...")
        print("‚è≥ Primeira vez pode demorar (download do modelo)...")
        
        # CORRE√á√ÉO CR√çTICA: Configurar FFmpeg ANTES de importar whisper
        import os
        import sys
        from pathlib import Path
        
        # Adicionar a pasta video_tools ao PATH
        ffmpeg_dir = str(self.folders['tools'])
        if os.path.exists(ffmpeg_dir):
            # Adicionar ao in√≠cio do PATH (maior prioridade)
            os.environ['PATH'] = ffmpeg_dir + os.pathsep + os.environ.get('PATH', '')
            print(f"üìÅ Usando FFmpeg de: {ffmpeg_dir}")
        
        try:
            # IMPORTANTE: Importar whisper DEPOIS de configurar o PATH
            import whisper
            
            print("üì¶ Carregando modelo Whisper...")
            model = whisper.load_model("base")
            
            print("üîÑ Transcrevendo...")
            # Converter Path para string se necess√°rio
            audio_path_str = str(audio_path) if not isinstance(audio_path, str) else audio_path
            
            # Verificar se o arquivo de √°udio existe
            if not os.path.exists(audio_path_str):
                print(f"‚ùå Arquivo de √°udio n√£o encontrado: {audio_path_str}")
                return None, None
            
            result = model.transcribe(audio_path_str, verbose=False)
            
            text = result.get('text', '').strip()
            language = result.get('language', 'unknown')
            
            if text:
                print(f"‚úÖ Transcri√ß√£o conclu√≠da! ({len(text)} caracteres)")
                print(f"üåç Idioma detectado: {self.languages.get(language, language)}")
                return result, language
            else:
                print("‚ö†Ô∏è Nenhum texto foi transcrito (arquivo pode estar silencioso ou corrompido)")
                return None, None
                
        except ImportError as e:
            print(f"‚ùå Erro importando Whisper: {e}")
            print("Execute: pip install openai-whisper")
            return None, None
        except FileNotFoundError as e:
            print(f"‚ùå FFmpeg n√£o encontrado pelo Whisper")
            print(f"Detalhes: {e}")
            return None, None
        except Exception as e:
            print(f"‚ùå Erro na transcri√ß√£o: {e}")
            # Imprimir mais detalhes para debug
            import traceback
            print("Detalhes do erro:")
            traceback.print_exc()
            return None, None

    def translate_text(self, text, target_lang, source_lang):
        """Fun√ß√£o de tradu√ß√£o desativada - retorna o texto original"""
        # Tradu√ß√£o offline removida
        print("‚ÑπÔ∏è Fun√ß√£o de tradu√ß√£o autom√°tica offline foi removida.")
        return text

    def save_all_formats(self, title, transcription_data, translated_text, source_lang, target_lang):
        """Salvar em todos os formatos dispon√≠veis"""
        safe_title = re.sub(r'[<>:"/\\|?*]', '_', title)
        base_path = self.folders['transcripts'] / safe_title
        # Texto da transcri√ß√£o
        original_text = transcription_data['text'] if isinstance(transcription_data, dict) else transcription_data
        results = {}
        # 1. TXT tradicional
        txt_path = f"{base_path}_transcription.txt"
        try:
            with open(txt_path, 'w', encoding='utf-8') as f:
                f.write(f"TRANSCRI√á√ÉO - {title}\n")
                f.write("=" * 60 + "\n")
                f.write(f"TRANSCRI√á√ÉO ORIGINAL ({self.languages.get(source_lang, source_lang)}):\n")
                f.write("-" * 40 + "\n")
                f.write(original_text + "\n")
                f.write("\nGerado por Enhanced Video Transcriber\n")
            results['txt'] = txt_path
            print(f"‚úÖ TXT salvo: {Path(txt_path).name}")
        except Exception as e:
            print(f"‚ùå Erro salvando TXT: {e}")
        # 2. JSON
        json_path = f"{base_path}_data.json"
        if self.export_to_json(transcription_data, json_path):
            results['json'] = json_path
        # 3. SRT
        srt_path = f"{base_path}_subtitles.srt"
        if self.export_to_srt(transcription_data, srt_path):
            results['srt'] = srt_path
        # 4. PDF
        pdf_path = f"{base_path}_document.pdf"
        # Passa o mesmo texto para original e traduzido para evitar bloco de tradu√ß√£o no PDF
        if self.export_to_pdf(title, original_text, original_text, source_lang, target_lang, pdf_path):
            results['pdf'] = pdf_path
        return results

    def process_audio_file(self, audio_path, title, target_lang='pt', detect_speakers=False):
        """Processar arquivo de √°udio direto"""
        print(f"üîä Processando arquivo de √°udio: {title}")
        try:
            # Escolher m√©todo de transcri√ß√£o
            if detect_speakers:
                transcription_data, source_lang = self.transcribe_with_speakers(audio_path)
            else:
                transcription_data, source_lang = self.transcribe_audio(audio_path)
            if not transcription_data:
                return False
            # Extrair texto principal
            original_text = transcription_data['text'] if isinstance(transcription_data, dict) else transcription_data
            # Mostrar transcri√ß√£o
            print("\n" + "="*60)
            print("TRANSCRI√á√ÉO:")
            print("="*60)
            preview = original_text[:300] + ("..." if len(original_text) > 300 else "")
            print(preview)
            print()
            # Tradu√ß√£o removida - n√£o perguntar mais
            translated_text = original_text # Sempre usar o texto original
            print("‚úÖ Salvando transcri√ß√£o")

            # Salvar em todos os formatos
            saved_files = self.save_all_formats(
                title, transcription_data, translated_text,
                source_lang, target_lang
            )
            print(f"\nüìÅ Arquivos salvos: {len(saved_files)}")
            for format_type, file_path in saved_files.items():
                print(f"  {format_type.upper()}: {Path(file_path).name}")
            return len(saved_files) > 0
        except Exception as e:
            print(f"‚ùå Erro no processamento: {e}")
            return False

    def process_video(self, video_source, target_lang='pt', detect_speakers=False):
        """Processar v√≠deo (URL ou arquivo local)"""
        title = None
        video_path = None
        # Determinar se √© URL ou arquivo
        if video_source.startswith(('http://', 'https://', 'www.')):
            video_path, title = self.download_video(video_source)
            if not video_path:
                return False
        else:
            video_path = video_source
            if not os.path.exists(video_path):
                print("‚ùå Arquivo n√£o encontrado!")
                return False
            title = Path(video_path).stem
        # Obter comando FFmpeg
        ffmpeg_cmd = self.setup_ffmpeg()
        if not ffmpeg_cmd:
            print("‚ùå FFmpeg necess√°rio!")
            return False
        # Extrair √°udio
        audio_path = self.extract_audio(video_path, title, ffmpeg_cmd)
        if not audio_path:
            return False
        try:
            # Processar √°udio
            result = self.process_audio_file(audio_path, title, target_lang, detect_speakers)
            return result
        finally:
            # Limpeza
            try:
                os.remove(audio_path)
            except:
                pass

    def live_recording_session(self, target_lang='pt', detect_speakers=False):
        """Sess√£o de grava√ß√£o ao vivo"""
        print("\nüé§ === GRAVA√á√ÉO AO VIVO ===")
        print("Escolha o modo de grava√ß√£o:")
        print("1. ‚è±Ô∏è Tempo determinado")
        print("2. üî¥ Pressionar Enter para parar")
        choice = input("Modo (1 ou 2): ").strip()
        duration = None
        if choice == '1':
            try:
                duration = int(input("Dura√ß√£o em segundos: "))
            except ValueError:
                print("‚ùå Dura√ß√£o inv√°lida, usando modo manual")
                duration = None
        # Gravar
        audio_path = self.record_audio_live(duration)
        if not audio_path:
            return False
        # Processar grava√ß√£o
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        title = f"Grava√ß√£o_{timestamp}"
        result = self.process_audio_file(audio_path, title, target_lang, detect_speakers)
        # Op√ß√£o de manter arquivo de √°udio
        keep_audio = input("\nüíæ Manter arquivo de √°udio original? (s/n): ").strip().lower()
        if keep_audio not in ['s', 'sim', 'y', 'yes']:
            try:
                os.remove(audio_path)
                print("üóëÔ∏è Arquivo de √°udio removido")
            except:
                pass
        return result

    def run(self):
        """Menu principal"""
        print("=" * 70)
        print("      VIDEO TRANSCRIBER - VERS√ÉO AVAN√áADA")
        print("  Transcri√ß√£o + Detec√ß√£o de Speakers + M√∫ltiplos Formatos")
        print("=" * 70)
        # Setup autom√°tico
        print("\nüöÄ Configura√ß√£o autom√°tica...")
        if not self.setup_dependencies():
            print("‚ùå Falha na configura√ß√£o!")
            return
        # setup_translation_models REMOVIDO
        print("\n‚úÖ Sistema avan√ßado pronto!")
        # Menu principal
        target_language = 'pt' # Mantido para compatibilidade e detec√ß√£o de idioma
        while True:
            print("\n" + "="*60)
            print("MENU PRINCIPAL - VERS√ÉO AVAN√áADA")
            print("="*60)
            print("1. üì∫ Transcrever v√≠deo do YouTube")
            print("2. üìÅ Transcrever arquivo de v√≠deo local")
            print("3. üîä Transcrever arquivo de √°udio (MP3/WAV)")
            print("4. üé§ Grava√ß√£o ao vivo do microfone")
            print("5. üåç (Desativado) Escolher idioma de tradu√ß√£o")
            print("6. üë• Ativar/desativar detec√ß√£o de speakers")
            print("7. üìÇ Abrir pasta de resultados")
            print("8. ‚ÑπÔ∏è  Sobre funcionalidades avan√ßadas")
            print("9. üö™ Sair")
            print(f"\nüåê Idioma de transcri√ß√£o detectado: {self.languages.get(target_language, target_language)}")
            # Status da detec√ß√£o de speakers
            speakers_enabled = getattr(self, 'speakers_enabled', False)
            print(f"üë• Detec√ß√£o de speakers: {'‚úÖ Ativada' if speakers_enabled else '‚ùå Desativada'}")
            print("üìù Formatos de sa√≠da: TXT, JSON, SRT, PDF")
            try:
                choice = input("\nEscolha: ").strip()
                if choice == '1':
                    url = input("\nüîó URL do YouTube: ").strip()
                    if url:
                        success = self.process_video(url, target_language, speakers_enabled)
                        print("\nüéâ Conclu√≠do!" if success else "\n‚ùå Erro no processo")
                elif choice == '2':
                    file_path = input("\nüìÅ Caminho do arquivo de v√≠deo: ").strip().replace('"', '')
                    if file_path:
                        success = self.process_video(file_path, target_language, speakers_enabled)
                        print("\nüéâ Conclu√≠do!" if success else "\n‚ùå Erro no processo")
                elif choice == '3':
                    file_path = input("\nüîä Caminho do arquivo de √°udio: ").strip().replace('"', '')
                    if file_path and os.path.exists(file_path):
                        title = Path(file_path).stem
                        success = self.process_audio_file(file_path, title, target_language, speakers_enabled)
                        print("\nüéâ Conclu√≠do!" if success else "\n‚ùå Erro no processo")
                    elif file_path:
                        print("‚ùå Arquivo n√£o encontrado!")
                elif choice == '4':
                    success = self.live_recording_session(target_language, speakers_enabled)
                    print("\nüéâ Grava√ß√£o processada!" if success else "\n‚ùå Erro na grava√ß√£o")
                elif choice == '5':
                    # Op√ß√£o desativada
                    print("\n‚ÑπÔ∏è A funcionalidade de tradu√ß√£o autom√°tica offline foi removida.")
                    print("üí° Voc√™ pode copiar o texto transcrito e usar um servi√ßo online como Google Tradutor.")
                elif choice == '6':
                    speakers_enabled = not getattr(self, 'speakers_enabled', False)
                    self.speakers_enabled = speakers_enabled
                    status = "ativada" if speakers_enabled else "desativada"
                    print(f"üë• Detec√ß√£o de speakers {status}")
                    if speakers_enabled:
                        print("‚ÑπÔ∏è  Isso detectar√° diferentes falantes no √°udio")
                        print("‚è≥ Primeira vez pode demorar (download do modelo)")
                elif choice == '7':
                    try:
                        if self.system == 'windows':
                            os.startfile(self.folders['transcripts'])
                        else:
                            subprocess.run(['xdg-open', str(self.folders['transcripts'])])
                        print("üìÇ Pasta aberta!")
                    except:
                        print(f"üìÇ Pasta: {self.folders['transcripts']}")
                elif choice == '8':
                    print("\n" + "="*60)
                    print("FUNCIONALIDADES AVAN√áADAS")
                    print("="*60)
                    print("\nüéôÔ∏è TRANSCRI√á√ÉO APRIMORADA:")
                    print("  ‚úÖ Whisper (OpenAI) - Estado da arte")
                    print("  ‚úÖ Detec√ß√£o autom√°tica de idioma")
                    print("  ‚úÖ Timestamps precisos para legendas")
                    print("  ‚úÖ Suporte a 99+ idiomas")
                    print("\nüë• DETEC√á√ÉO DE SPEAKERS:")
                    print("  ‚úÖ Identifica diferentes falantes")
                    print("  ‚úÖ Timestamps por speaker")
                    print("  ‚úÖ Estat√≠sticas de tempo de fala")
                    print("  ‚è≥ Requer modelo adicional (pyannote)")
                    print("\nüìÅ FORMATOS DE SA√çDA:")
                    print("  üìù TXT - Texto simples formatado")
                    print("  üìä JSON - Dados completos com metadados")
                    print("  üé¨ SRT - Legendas para v√≠deos")
                    print("  üìÑ PDF - Documento profissional")
                    print("\nüîä FONTES DE √ÅUDIO:")
                    print("  üì∫ YouTube (yt-dlp)")
                    print("  üìÅ Arquivos de v√≠deo locais")
                    print("  üîä Arquivos de √°udio (MP3, WAV, etc.)")
                    print("  üé§ Grava√ß√£o ao vivo do microfone")
                    print("\nüåê TRADU√á√ÉO:")
                    print("  ‚ùå Tradu√ß√£o autom√°tica offline foi removida.")
                    print("  üí° Use a transcri√ß√£o e um servi√ßo online manualmente.")
                elif choice == '9':
                    print("\nüëã Obrigado por usar o Video Transcriber Avan√ßado!")
                    break
                else:
                    print("\n‚ùå Op√ß√£o inv√°lida!")
            except KeyboardInterrupt:
                print("\nüëã Saindo...")
                break
            except Exception as e:
                print(f"\n‚ùå Erro: {e}")

def main():
    """Fun√ß√£o principal"""
    try:
        app = EnhancedVideoTranscriber()
        app.run()
    except Exception as e:
        print(f"‚ùå Erro fatal: {e}")
        import traceback
        traceback.print_exc()
    finally:
        input("\nPressione Enter para fechar...")

if __name__ == '__main__':
    main()